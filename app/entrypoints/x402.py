import logging
from typing import Annotated, List, Optional

from epyxid import XID
from fastapi import APIRouter, Request
from pydantic import BaseModel, ConfigDict, Field

from intentkit.core.engine import execute_agent
from intentkit.models.agent import Agent
from intentkit.models.chat import (
    AuthorType,
    ChatMessage,
    ChatMessageAttachment,
    ChatMessageCreate,
)
from intentkit.utils.error import IntentKitAPIError

logger = logging.getLogger(__name__)

x402_router = APIRouter()


class X402MessageRequest(BaseModel):
    """Request model for X402 messages.

    This model represents the request body for creating a new X402 message.
    It contains the necessary fields for message content and agent identification,
    along with optional attachments. The user_id and chat_id are hardcoded.
    """

    agent_id: Annotated[
        str,
        Field(
            ...,
            description="Agent ID to send the message to",
            examples=["agent-123"],
        ),
    ]
    app_id: Annotated[
        Optional[str],
        Field(
            None,
            description="Optional application identifier",
            examples=["app-789"],
        ),
    ]
    message: Annotated[
        str,
        Field(
            ...,
            description="Content of the message",
            examples=["Hello, how can you help me today?"],
            min_length=1,
            max_length=65535,
        ),
    ]
    search_mode: Annotated[
        Optional[bool],
        Field(
            None,
            description="Optional flag to enable search mode",
        ),
    ]
    super_mode: Annotated[
        Optional[bool],
        Field(
            None,
            description="Optional flag to enable super mode",
        ),
    ]
    attachments: Annotated[
        Optional[List[ChatMessageAttachment]],
        Field(
            None,
            description="Optional list of attachments (links, images, or files)",
            examples=[[{"type": "link", "url": "https://example.com"}]],
        ),
    ]

    model_config = ConfigDict(
        use_enum_values=True,
        json_schema_extra={
            "example": {
                "agent_id": "agent-123",
                "message": "Hello, how can you help me today?",
            }
        },
    )


@x402_router.post(
    "/",
    response_model=List[ChatMessage],
    operation_id="send_x402_message",
    summary="Send a message via X402",
    description=(
        "Send a new message via X402 endpoint. The response is a list of messages generated by the agent. "
        "The response does not include the original user message. It could be skill calls, agent messages, or system error messages. "
        "This endpoint uses hardcoded chat_id='x402' and user_id='x402', and stream is always disabled."
    ),
    tags=["X402"],
)
async def send_message(
    request: X402MessageRequest,
    raw_request: Request,
):
    """Send a new message via X402."""
    # Hardcoded values
    chat_id = "x402"
    user_id = "x402"

    # Check if request.state exists and has verify_response with payer
    if hasattr(raw_request, "state") and hasattr(raw_request.state, "verify_response"):
        verify_response = raw_request.state.verify_response
        if hasattr(verify_response, "payer") and verify_response.payer:
            user_id = verify_response.payer

    agent_id = request.agent_id
    agent = await Agent.get_by_id_or_slug(agent_id)
    if not agent:
        raise IntentKitAPIError(
            status_code=400, key="AgentNotFound", message=f"Agent {agent_id} not found"
        )

    user_message = ChatMessageCreate(
        id=str(XID()),
        agent_id=agent.id,
        chat_id=chat_id,
        user_id=user_id,
        author_id=user_id,
        author_type=AuthorType.API,
        thread_type=AuthorType.API,
        message=request.message,
        attachments=request.attachments,
        model=None,
        reply_to=None,
        skill_calls=None,
        input_tokens=0,
        output_tokens=0,
        time_cost=0.0,
        credit_event_id=None,
        credit_cost=None,
        cold_start_cost=0.0,
        app_id=request.app_id,
        search_mode=request.search_mode,
        super_mode=request.super_mode,
    )

    # Stream is hardcoded to False, so we always use execute_agent
    response_messages = await execute_agent(user_message)
    # Return messages list directly for compatibility with stream mode
    return [message.sanitize_privacy() for message in response_messages]
